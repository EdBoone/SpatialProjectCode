#--------------------------------------------------------------------------------# Run Times for# (N=1000, Burn-in=750,  Nw=250)# (N=5000, Burn-in=3750, Nw=1250)## MacBook Pro, macOS Big Sur (v 11.5.2)# 2.8 MHz Quad-Core Intel Core i7# 16 GB 2133 MHz LPDDR3## Dell Machine, Windows 10# intel Core i9-11900H# RAM 32 GB## N = n.samples# Nw = n.samples - burn.in##                      MacBook Pro           Dell PC             Monica's HPC#   n    N     Nw      [th]  [be,w|th]    [th]    [be,w|th]      [th]   [be,w|th]#---------------------------------------------------------------------------------#  100  1000   250   1.53 sec  2.75 sec#  200  1000   250   8.56 sec 21.21 sec#  400  1000   250   1.13 min  3.28 min#  500  1000   250   1.97 min  6.73 min  1.80 min   5.44 min   1.81 min   2.01 min#  500  5000  1250                       9.37 min  26.26 min   5.28 min   5.69 min# 1000  1000   250  15.00 min  1.13 hour                       # 1000 50000 12500                                             6.17 hrs   8.76 hrs# 1000  5000  1250  #---------------------------------------------------------------------------------   library(spBayes)library(coda)# NOT RUN {rmvn <- function(n, mu=0, V = matrix(1)){  p <- length(mu)  if(any(is.na(match(dim(V),p)))){stop("Dimension problem!")}  D <- chol(V)  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))}set.seed(1)##Generate some datan <- 1000 ##number of locationsq <- 2 ##number of outcomes at each locationnltr <- q*(q+1)/2 ##number of triangular elements in the cross-covariance matrixcoords <- cbind(runif(n,0,1), runif(n,0,1))##Parameters for the bivariate spatial random effectstheta <- rep(3/0.5,q)A <- matrix(0,q,q)A[lower.tri(A,TRUE)] <- c(1,-1,0.25)K <- A%*%t(A)Psi <- diag(0,q)C <- mkSpCov(coords, K, Psi, theta, cov.model="exponential")w <- rmvn(1, rep(0,nrow(C)), C)w.1 <- w[seq(1,length(w),q)]w.2 <- w[seq(2,length(w),q)]##Covariate portion of the meanx.1 <- cbind(1, rnorm(n))x.2 <- cbind(1, rnorm(n))x <- mkMvX(list(x.1, x.2))B.1 <- c(1,-1)B.2 <- c(-1,1)B <- c(B.1, B.2)Psi <- diag(c(0.1, 0.5))y <- rnorm(n*q, x%*%B+w, diag(n)%x%Psi)y.1 <- y[seq(1,length(y),q)]y.2 <- y[seq(2,length(y),q)]##Call spMvLMA.starting <- diag(1,q)[lower.tri(diag(1,q), TRUE)]n.samples <- 1000starting <- list("phi"=rep(3/0.5,q), "A"=A.starting, "Psi"=rep(1,q))tuning <- list("phi"=rep(1,q), "A"=rep(0.01,length(A.starting)), "Psi"=rep(0.01,q))priors <- list("beta.Flat", "phi.Unif"=list(rep(3/0.75,q), rep(3/0.25,q)),               "K.IW"=list(q+1, diag(0.1,q)), "Psi.ig"=list(c(2,2), c(0.1,0.1)))time1 = Sys.time()m.1 <- spMvLM(list(y.1~x.1-1, y.2~x.2-1),                coords=coords, starting=starting, tuning=tuning, priors=priors,               n.samples=n.samples, cov.model="exponential", n.report=100)	       time2 = Sys.time()burn.in <- 0.75*n.samplesm.1 <- spRecover(m.1, start=burn.in)time3 = Sys.time()cat(sprintf("\n---------------------------------------------\n"))cat(sprintf("Model and Algorithm Inputs\n"))cat(sprintf("n = %d\n",n))cat(sprintf("q = %d\n",q))cat(sprintf("niter = %d\n",n.samples))cat(sprintf("burn  = %d\n",burn.in))cat(sprintf("---------------------------------------------\n"))cat(sprintf("Run Times\n"))cat(sprintf("p(theta):   %.2f\n",round(time2-time1,2)))cat(sprintf("p(beta,w):  %.2f\n",round(time3-time2,2)))cat(sprintf("---------------------------------------------\n"))round(summary(m.1$p.theta.recover.samples)$quantiles[,c(3,1,5)],2)round(summary(m.1$p.beta.recover.samples)$quantiles[,c(3,1,5)],2)m.1.w.hat <- summary(mcmc(t(m.1$p.w.recover.samples)))$quantiles[,c(3,1,5)]m.1.w.1.hat <- m.1.w.hat[seq(1, nrow(m.1.w.hat), q),]m.1.w.2.hat <- m.1.w.hat[seq(2, nrow(m.1.w.hat), q),]par(mfrow=c(1,2))plot(w.1, m.1.w.1.hat[,1], xlab="Observed w.1", ylab="Fitted w.1",     xlim=range(w), ylim=range(m.1.w.hat), main="Spatial random effects w.1")arrows(w.1, m.1.w.1.hat[,1], w.1, m.1.w.1.hat[,2], length=0.02, angle=90)arrows(w.1, m.1.w.1.hat[,1], w.1, m.1.w.1.hat[,3], length=0.02, angle=90)lines(range(w), range(w))plot(w.2, m.1.w.2.hat[,1], xlab="Observed w.2", ylab="Fitted w.2",     xlim=range(w), ylim=range(m.1.w.hat), main="Spatial random effects w.2")arrows(w.2, m.1.w.2.hat[,1], w.2, m.1.w.2.hat[,2], length=0.02, angle=90)arrows(w.2, m.1.w.2.hat[,1], w.2, m.1.w.2.hat[,3], length=0.02, angle=90)lines(range(w), range(w))# }